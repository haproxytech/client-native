// Code generated by go-method-gen. DO NOT EDIT.

// Copyright 2019 HAProxy Technologies
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package models

import (
	"github.com/go-openapi/strfmt"
	"github.com/haproxytech/client-native/v6/models/funcs"
	"github.com/haproxytech/go-method-gen/pkg/eqdiff"
)

func (rec SslCertificate) Diff(obj SslCertificate, opts ...eqdiff.GoMethodGenOptions) map[string][]interface{} {
	diff := make(map[string][]interface{})
	if rec.Algorithm != obj.Algorithm {
		diff["Algorithm"] = []interface{}{rec.Algorithm, obj.Algorithm}
	}
	if rec.AuthorityKeyID != obj.AuthorityKeyID {
		diff["AuthorityKeyID"] = []interface{}{rec.AuthorityKeyID, obj.AuthorityKeyID}
	}
	if rec.ChainIssuer != obj.ChainIssuer {
		diff["ChainIssuer"] = []interface{}{rec.ChainIssuer, obj.ChainIssuer}
	}
	if rec.ChainSubject != obj.ChainSubject {
		diff["ChainSubject"] = []interface{}{rec.ChainSubject, obj.ChainSubject}
	}
	if rec.Description != obj.Description {
		diff["Description"] = []interface{}{rec.Description, obj.Description}
	}
	if rec.Domains != obj.Domains {
		diff["Domains"] = []interface{}{rec.Domains, obj.Domains}
	}
	if rec.File != obj.File {
		diff["File"] = []interface{}{rec.File, obj.File}
	}
	if rec.IPAddresses != obj.IPAddresses {
		diff["IPAddresses"] = []interface{}{rec.IPAddresses, obj.IPAddresses}
	}
	if rec.Issuers != obj.Issuers {
		diff["Issuers"] = []interface{}{rec.Issuers, obj.Issuers}
	}
	for diffKey, diffValue := range DiffPointerStrfmtDateTime(rec.NotAfter, obj.NotAfter, opts...) {
		diff["NotAfter."+diffKey] = diffValue
	}
	for diffKey, diffValue := range DiffPointerStrfmtDateTime(rec.NotBefore, obj.NotBefore, opts...) {
		diff["NotBefore."+diffKey] = diffValue
	}
	if rec.Serial != obj.Serial {
		diff["Serial"] = []interface{}{rec.Serial, obj.Serial}
	}
	if rec.Sha1FingerPrint != obj.Sha1FingerPrint {
		diff["Sha1FingerPrint"] = []interface{}{rec.Sha1FingerPrint, obj.Sha1FingerPrint}
	}
	if rec.Sha256FingerPrint != obj.Sha256FingerPrint {
		diff["Sha256FingerPrint"] = []interface{}{rec.Sha256FingerPrint, obj.Sha256FingerPrint}
	}
	for diffKey, diffValue := range DiffPointerInt64(rec.Size, obj.Size, opts...) {
		diff["Size."+diffKey] = diffValue
	}
	if rec.Status != obj.Status {
		diff["Status"] = []interface{}{rec.Status, obj.Status}
	}
	if rec.StorageName != obj.StorageName {
		diff["StorageName"] = []interface{}{rec.StorageName, obj.StorageName}
	}
	if rec.Subject != obj.Subject {
		diff["Subject"] = []interface{}{rec.Subject, obj.Subject}
	}
	if rec.SubjectAlternativeNames != obj.SubjectAlternativeNames {
		diff["SubjectAlternativeNames"] = []interface{}{rec.SubjectAlternativeNames, obj.SubjectAlternativeNames}
	}
	if rec.SubjectKeyID != obj.SubjectKeyID {
		diff["SubjectKeyID"] = []interface{}{rec.SubjectKeyID, obj.SubjectKeyID}
	}
	return diff
}

func DiffPointerStrfmtDateTime(x, y *strfmt.DateTime, opts ...eqdiff.GoMethodGenOptions) map[string][]interface{} {
	diff := make(map[string][]interface{})
	if x == nil && y == nil {
		return diff
	}

	key := "NotBefore"

	switch {
	case x == nil:
		diff[key] = []interface{}{x, *y}
		return diff
	case y == nil:
		diff[key] = []interface{}{*x, y}
		return diff
	}

	for diffKey, diffValue := range funcs.DiffStrfmtDateTime(*x, *y) {
		diff[key+"."+diffKey] = diffValue
	}

	return diff
}
