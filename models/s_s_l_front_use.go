// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2019 HAProxy Technologies
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SSLFrontUse SSL Frontend Use certificate
//
// # Assign a certificate to the current frontend
//
// swagger:model SSLFrontUse
type SSLFrontUse struct {

	// allow 0rtt
	Allow0rtt bool `json:"allow_0rtt,omitempty"`

	// alpn
	Alpn string `json:"alpn,omitempty"`

	// ca file
	CaFile string `json:"ca_file,omitempty"`

	// Certificate filename
	// Required: true
	// Pattern: ^[^\s]+$
	// +kubebuilder:validation:Pattern=`^[^\s]+$`
	Certificate string `json:"certificate"`

	// ciphers
	Ciphers string `json:"ciphers,omitempty"`

	// ciphersuites
	Ciphersuites string `json:"ciphersuites,omitempty"`

	// client sigalgs
	ClientSigalgs string `json:"client_sigalgs,omitempty"`

	// crl file
	CrlFile string `json:"crl_file,omitempty"`

	// curves
	Curves string `json:"curves,omitempty"`

	// ecdhe
	Ecdhe string `json:"ecdhe,omitempty"`

	// OCSP issuer filename
	Issuer string `json:"issuer,omitempty"`

	// Private key filename
	Key string `json:"key,omitempty"`

	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// no alpn
	NoAlpn bool `json:"no_alpn,omitempty"`

	// no ca names
	NoCaNames bool `json:"no_ca_names,omitempty"`

	// npn
	Npn string `json:"npn,omitempty"`

	// OCSP response filename
	Ocsp string `json:"ocsp,omitempty"`

	// Automatic OCSP response update
	// Enum: [enabled disabled]
	// +kubebuilder:validation:Enum=enabled disabled;
	OcspUpdate string `json:"ocsp_update,omitempty"`

	// Signed Certificate Timestamp List filename
	Sctl string `json:"sctl,omitempty"`

	// sigalgs
	Sigalgs string `json:"sigalgs,omitempty"`

	// ssl max ver
	// Enum: [SSLv3 TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3]
	// +kubebuilder:validation:Enum=SSLv3 TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3;
	SslMaxVer string `json:"ssl_max_ver,omitempty"`

	// ssl min ver
	// Enum: [SSLv3 TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3]
	// +kubebuilder:validation:Enum=SSLv3 TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3;
	SslMinVer string `json:"ssl_min_ver,omitempty"`

	// verify
	// Enum: [none optional required]
	// +kubebuilder:validation:Enum=none optional required;
	Verify string `json:"verify,omitempty"`
}

// Validate validates this s s l front use
func (m *SSLFrontUse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOcspUpdate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSslMaxVer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSslMinVer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerify(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SSLFrontUse) validateCertificate(formats strfmt.Registry) error {

	if err := validate.RequiredString("certificate", "body", m.Certificate); err != nil {
		return err
	}

	if err := validate.Pattern("certificate", "body", m.Certificate, `^[^\s]+$`); err != nil {
		return err
	}

	return nil
}

var sSLFrontUseTypeOcspUpdatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["enabled","disabled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sSLFrontUseTypeOcspUpdatePropEnum = append(sSLFrontUseTypeOcspUpdatePropEnum, v)
	}
}

const (

	// SSLFrontUseOcspUpdateEnabled captures enum value "enabled"
	SSLFrontUseOcspUpdateEnabled string = "enabled"

	// SSLFrontUseOcspUpdateDisabled captures enum value "disabled"
	SSLFrontUseOcspUpdateDisabled string = "disabled"
)

// prop value enum
func (m *SSLFrontUse) validateOcspUpdateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sSLFrontUseTypeOcspUpdatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SSLFrontUse) validateOcspUpdate(formats strfmt.Registry) error {
	if swag.IsZero(m.OcspUpdate) { // not required
		return nil
	}

	// value enum
	if err := m.validateOcspUpdateEnum("ocsp_update", "body", m.OcspUpdate); err != nil {
		return err
	}

	return nil
}

var sSLFrontUseTypeSslMaxVerPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SSLv3","TLSv1.0","TLSv1.1","TLSv1.2","TLSv1.3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sSLFrontUseTypeSslMaxVerPropEnum = append(sSLFrontUseTypeSslMaxVerPropEnum, v)
	}
}

const (

	// SSLFrontUseSslMaxVerSSLv3 captures enum value "SSLv3"
	SSLFrontUseSslMaxVerSSLv3 string = "SSLv3"

	// SSLFrontUseSslMaxVerTLSv1Dot0 captures enum value "TLSv1.0"
	SSLFrontUseSslMaxVerTLSv1Dot0 string = "TLSv1.0"

	// SSLFrontUseSslMaxVerTLSv1Dot1 captures enum value "TLSv1.1"
	SSLFrontUseSslMaxVerTLSv1Dot1 string = "TLSv1.1"

	// SSLFrontUseSslMaxVerTLSv1Dot2 captures enum value "TLSv1.2"
	SSLFrontUseSslMaxVerTLSv1Dot2 string = "TLSv1.2"

	// SSLFrontUseSslMaxVerTLSv1Dot3 captures enum value "TLSv1.3"
	SSLFrontUseSslMaxVerTLSv1Dot3 string = "TLSv1.3"
)

// prop value enum
func (m *SSLFrontUse) validateSslMaxVerEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sSLFrontUseTypeSslMaxVerPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SSLFrontUse) validateSslMaxVer(formats strfmt.Registry) error {
	if swag.IsZero(m.SslMaxVer) { // not required
		return nil
	}

	// value enum
	if err := m.validateSslMaxVerEnum("ssl_max_ver", "body", m.SslMaxVer); err != nil {
		return err
	}

	return nil
}

var sSLFrontUseTypeSslMinVerPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SSLv3","TLSv1.0","TLSv1.1","TLSv1.2","TLSv1.3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sSLFrontUseTypeSslMinVerPropEnum = append(sSLFrontUseTypeSslMinVerPropEnum, v)
	}
}

const (

	// SSLFrontUseSslMinVerSSLv3 captures enum value "SSLv3"
	SSLFrontUseSslMinVerSSLv3 string = "SSLv3"

	// SSLFrontUseSslMinVerTLSv1Dot0 captures enum value "TLSv1.0"
	SSLFrontUseSslMinVerTLSv1Dot0 string = "TLSv1.0"

	// SSLFrontUseSslMinVerTLSv1Dot1 captures enum value "TLSv1.1"
	SSLFrontUseSslMinVerTLSv1Dot1 string = "TLSv1.1"

	// SSLFrontUseSslMinVerTLSv1Dot2 captures enum value "TLSv1.2"
	SSLFrontUseSslMinVerTLSv1Dot2 string = "TLSv1.2"

	// SSLFrontUseSslMinVerTLSv1Dot3 captures enum value "TLSv1.3"
	SSLFrontUseSslMinVerTLSv1Dot3 string = "TLSv1.3"
)

// prop value enum
func (m *SSLFrontUse) validateSslMinVerEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sSLFrontUseTypeSslMinVerPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SSLFrontUse) validateSslMinVer(formats strfmt.Registry) error {
	if swag.IsZero(m.SslMinVer) { // not required
		return nil
	}

	// value enum
	if err := m.validateSslMinVerEnum("ssl_min_ver", "body", m.SslMinVer); err != nil {
		return err
	}

	return nil
}

var sSLFrontUseTypeVerifyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","optional","required"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sSLFrontUseTypeVerifyPropEnum = append(sSLFrontUseTypeVerifyPropEnum, v)
	}
}

const (

	// SSLFrontUseVerifyNone captures enum value "none"
	SSLFrontUseVerifyNone string = "none"

	// SSLFrontUseVerifyOptional captures enum value "optional"
	SSLFrontUseVerifyOptional string = "optional"

	// SSLFrontUseVerifyRequired captures enum value "required"
	SSLFrontUseVerifyRequired string = "required"
)

// prop value enum
func (m *SSLFrontUse) validateVerifyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sSLFrontUseTypeVerifyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SSLFrontUse) validateVerify(formats strfmt.Registry) error {
	if swag.IsZero(m.Verify) { // not required
		return nil
	}

	// value enum
	if err := m.validateVerifyEnum("verify", "body", m.Verify); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this s s l front use based on context it is used
func (m *SSLFrontUse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SSLFrontUse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SSLFrontUse) UnmarshalBinary(b []byte) error {
	var res SSLFrontUse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
